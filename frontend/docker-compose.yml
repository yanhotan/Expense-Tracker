version: '3'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      # Add your environment variables here
      - NEXT_PUBLIC_SUPABASE_URL=https://kvztrixrtsbtymwewkuo.supabase.co
      - NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt2enRyaXhydHNidHltd2V3a3VvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU4MjMyMDYsImV4cCI6MjA2MTM5OTIwNn0.r8VwAhLN0QHsBVgeZyv-lzBSlhpXAhUjJnMAakQ8tDk
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s

-- Create expense_sheets table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.expense_sheets (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    pin TEXT,
    has_pin BOOLEAN DEFAULT false,
    user_id UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create expenses table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.expenses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    date DATE NOT NULL,
    amount NUMERIC NOT NULL,
    category TEXT NOT NULL,
    description TEXT,
    user_id UUID NOT NULL,
    sheet_id UUID REFERENCES public.expense_sheets(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create an index on user_id for both tables to speed up queries
CREATE INDEX IF NOT EXISTS expenses_user_id_idx ON public.expenses(user_id);
CREATE INDEX IF NOT EXISTS expense_sheets_user_id_idx ON public.expense_sheets(user_id);

-- Create an index on sheet_id in expenses for faster lookup
CREATE INDEX IF NOT EXISTS expenses_sheet_id_idx ON public.expenses(sheet_id);

-- Enable RLS (Row Level Security) - moved here after tables are created
ALTER TABLE public.expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.expense_sheets ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for expense_sheets

-- Allow users to select only their own sheets
CREATE POLICY select_own_sheets
    ON public.expense_sheets
    FOR SELECT
    USING (auth.uid() = user_id);

-- Allow users to insert their own sheets
CREATE POLICY insert_own_sheets
    ON public.expense_sheets
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- Allow users to update only their own sheets
CREATE POLICY update_own_sheets
    ON public.expense_sheets
    FOR UPDATE
    USING (auth.uid() = user_id);

-- Allow users to delete only their own sheets
CREATE POLICY delete_own_sheets
    ON public.expense_sheets
    FOR DELETE
    USING (auth.uid() = user_id);

-- Create RLS policies for expenses

-- Allow users to select only their own expenses
CREATE POLICY select_own_expenses
    ON public.expenses
    FOR SELECT
    USING (auth.uid() = user_id);

-- Allow users to insert their own expenses
CREATE POLICY insert_own_expenses
    ON public.expenses
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- Allow users to update only their own expenses
CREATE POLICY update_own_expenses
    ON public.expenses
    FOR UPDATE
    USING (auth.uid() = user_id);

-- Allow users to delete only their own expenses
CREATE POLICY delete_own_expenses
    ON public.expenses
    FOR DELETE
    USING (auth.uid() = user_id);

-- Create a function to get category totals for a user
CREATE OR REPLACE FUNCTION public.get_category_totals(user_uuid UUID, sheet_uuid UUID DEFAULT NULL)
RETURNS TABLE (category TEXT, total NUMERIC) AS $$
BEGIN
    IF sheet_uuid IS NULL THEN
        RETURN QUERY
        SELECT e.category, SUM(e.amount) as total
        FROM public.expenses e
        WHERE e.user_id = user_uuid
        GROUP BY e.category
        ORDER BY total DESC;
    ELSE
        RETURN QUERY
        SELECT e.category, SUM(e.amount) as total
        FROM public.expenses e
        WHERE e.user_id = user_uuid AND e.sheet_id = sheet_uuid
        GROUP BY e.category
        ORDER BY total DESC;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a function to get monthly totals for a user
CREATE OR REPLACE FUNCTION public.get_monthly_totals(user_uuid UUID, sheet_uuid UUID DEFAULT NULL)
RETURNS TABLE (month TEXT, total NUMERIC) AS $$
BEGIN
    IF sheet_uuid IS NULL THEN
        RETURN QUERY
        SELECT 
            TO_CHAR(e.date, 'Mon YYYY') as month,
            SUM(e.amount) as total
        FROM public.expenses e
        WHERE e.user_id = user_uuid
        GROUP BY TO_CHAR(e.date, 'Mon YYYY'), EXTRACT(YEAR FROM e.date), EXTRACT(MONTH FROM e.date)
        ORDER BY MIN(e.date) DESC;
    ELSE
        RETURN QUERY
        SELECT 
            TO_CHAR(e.date, 'Mon YYYY') as month,
            SUM(e.amount) as total
        FROM public.expenses e
        WHERE e.user_id = user_uuid AND e.sheet_id = sheet_uuid
        GROUP BY TO_CHAR(e.date, 'Mon YYYY'), EXTRACT(YEAR FROM e.date), EXTRACT(MONTH FROM e.date)
        ORDER BY MIN(e.date) DESC;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a function to get the current month's total for a user
CREATE OR REPLACE FUNCTION public.get_current_month_total(user_uuid UUID, sheet_uuid UUID DEFAULT NULL)
RETURNS NUMERIC AS $$
DECLARE
    total_amount NUMERIC;
BEGIN
    IF sheet_uuid IS NULL THEN
        SELECT COALESCE(SUM(amount), 0) INTO total_amount
        FROM public.expenses
        WHERE user_id = user_uuid
        AND EXTRACT(MONTH FROM date) = EXTRACT(MONTH FROM CURRENT_DATE)
        AND EXTRACT(YEAR FROM date) = EXTRACT(YEAR FROM CURRENT_DATE);
    ELSE
        SELECT COALESCE(SUM(amount), 0) INTO total_amount
        FROM public.expenses
        WHERE user_id = user_uuid
        AND sheet_id = sheet_uuid
        AND EXTRACT(MONTH FROM date) = EXTRACT(MONTH FROM CURRENT_DATE)
        AND EXTRACT(YEAR FROM date) = EXTRACT(YEAR FROM CURRENT_DATE);
    END IF;
    
    RETURN total_amount;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a function to get the previous month's total for a user
CREATE OR REPLACE FUNCTION public.get_previous_month_total(user_uuid UUID, sheet_uuid UUID DEFAULT NULL)
RETURNS NUMERIC AS $$
DECLARE
    total_amount NUMERIC;
    prev_month INTEGER;
    prev_year INTEGER;
BEGIN
    -- Calculate previous month and year
    IF EXTRACT(MONTH FROM CURRENT_DATE) = 1 THEN
        prev_month := 12;
        prev_year := EXTRACT(YEAR FROM CURRENT_DATE) - 1;
    ELSE
        prev_month := EXTRACT(MONTH FROM CURRENT_DATE) - 1;
        prev_year := EXTRACT(YEAR FROM CURRENT_DATE);
    END IF;
    
    IF sheet_uuid IS NULL THEN
        SELECT COALESCE(SUM(amount), 0) INTO total_amount
        FROM public.expenses
        WHERE user_id = user_uuid
        AND EXTRACT(MONTH FROM date) = prev_month
        AND EXTRACT(YEAR FROM date) = prev_year;
    ELSE
        SELECT COALESCE(SUM(amount), 0) INTO total_amount
        FROM public.expenses
        WHERE user_id = user_uuid
        AND sheet_id = sheet_uuid
        AND EXTRACT(MONTH FROM date) = prev_month
        AND EXTRACT(YEAR FROM date) = prev_year;
    END IF;
    
    RETURN total_amount;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a function to get user's top expense categories
CREATE OR REPLACE FUNCTION public.get_top_categories(user_uuid UUID, limit_count INTEGER DEFAULT 5, sheet_uuid UUID DEFAULT NULL)
RETURNS TABLE (category TEXT, total NUMERIC) AS $$
BEGIN
    IF sheet_uuid IS NULL THEN
        RETURN QUERY
        SELECT e.category, SUM(e.amount) as total
        FROM public.expenses e
        WHERE e.user_id = user_uuid
        GROUP BY e.category
        ORDER BY total DESC
        LIMIT limit_count;
    ELSE
        RETURN QUERY
        SELECT e.category, SUM(e.amount) as total
        FROM public.expenses e
        WHERE e.user_id = user_uuid AND e.sheet_id = sheet_uuid
        GROUP BY e.category
        ORDER BY total DESC
        LIMIT limit_count;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;